<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
      给你一个以行程长度编码压缩的整数列表 nums 。

      考虑每对相邻的两个元素 [freq, val] = [nums[2*i], nums[2*i+1]] （其中 i >= 0 ），每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。

      请你返回解压后的列表。

       

      示例：

      输入：nums = [1,2,3,4]
      输出：[2,4,4,4]
      解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。
      第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。
      最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。
      示例 2：

      输入：nums = [1,1,2,3]
      输出：[1,3,3]
       

      提示：

      2 <= nums.length <= 100
      nums.length % 2 == 0
      1 <= nums[i] <= 100
    */
      /**
       * @param {number[]} nums
       * @return {number[]}
       */
      // 双循环
      // var decompressRLElist = function (nums) {
      //   const ans = []
      //   let i = 0
      //   // 第一层循环每次的索引指向 nums 的偶数索引位置
      //   for(let i = 0; i < nums.length; ) {
      //     // 第二层循环的次数是偶数索引位置的数字
      //     for(let j = 0; j < nums[i]; j++) {
      //       ans.push(nums[i + 1]) // 添加的值是当前索引后面的值
      //     }

      //     i += 2 // 索引加2，指向下一个奇数位的数字
      //   }
      //   return ans
      // };

      // 单循环
      var decompressRLElist = function (nums) {
        let ans = []
        for(let i = 0, len = nums.length / 2; i < len; i += 1) {
          ans = [...ans, ...new Array(nums[2*i]).fill(nums[2*i+1])]
        }
        return ans
      }
      console.log(decompressRLElist(nums = [1,2,3,4])) // [2,4,4,4]
      console.log(decompressRLElist(nums = [1,1,2,3])) // [1,3,3]
    </script>
  </body>
</html>
